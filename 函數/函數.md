1. 函數是什麼？一個生活化的概念
想像一下，你想喝一杯「去冰、半糖的珍珠奶茶」。你不會自己從煮茶、搖茶、準備珍珠開始做起，而是會走到飲料店，跟店員下指令。

在這個過程中：

你 (主程式)：想要完成「喝到飲料」這個大目標。

店員 (函數)：是一個專門負責「製作飲料」的專家。

「去冰、半糖、珍珠奶茶」 (參數)：是你提供給店員的具體指令和材料。

店員依照你的指令製作飲料 (函數的處理過程)：這是在「櫃檯後方」發生的事，你不需要知道所有細節，你只需要相信店員會做好。

一杯完成的飲料 (回傳值)：是店員完成任務後，交還給你的最終成果。

在程式中，「函數」就像是這位飲料店店員。 我們可以把一個重複性的任務（例如：計算面積、驗證密碼、連接資料庫）包裝成一個函數。當主程式需要執行這個任務時，只需要「呼叫」這個函數，並提供必要的資訊（參數），然後等待它完成任務並（可能）回傳一個結果。

這樣做的好處顯而易見：

程式碼重用：不用每次想喝飲料都自己從頭做一遍。

簡化主流程：主程式只需要下指令，而不用關心製作飲料的繁瑣細節。

易於維護：如果飲料的配方需要調整，只需要修改「店員」的作法，而不用動到「你」下指令的流程。

2. 函數的定義與呼叫
現在，我們來看看在 C++ 中如何實際操作「店員」。

內建函數 (Built-in Functions)
C++ 語言本身已經內建了許多方便的「資深店員」，我們稱之為內建函數或函式庫函數。例如，計算平方根的 sqrt()。
```c++
#include <iostream>
#include <cmath> // 要使用 sqrt 必須引用 cmath 函式庫

int main() {
    // 呼叫 cmath 函式庫中的 sqrt 函數
    // 就像跟店員說：「幫我算一下 16 的平方根」
    double result = sqrt(16.0); 
    
    cout << "16 的平方根是: " << result << endl; // 輸出: 16 的平方根是: 4
    return 0;
}

無回傳值的自訂函數 (void)
有時候，我們只想讓函數執行一個動作，而不需要它回傳任何結果。就像你對智慧音箱說「嘿 Siri，關燈」，你只需要它執行動作，不用回報「好的，燈已關閉」。

在 C++ 中，我們使用 void (空) 來表示這個函數沒有回傳值。

#include <iostream>

// --- 定義一個名為 sayHello 的函數 ---
// void 表示這個函數不回傳任何東西
void sayHello(std::string name) {
    std::cout << "你好, " << name << "！ 歡迎來到 C++ 的世界。" << std::endl;
}

int main() {
    // --- 呼叫 (Call) 函數 ---
    sayHello("小明"); // 傳遞 "小明" 作為參數
    sayHello("小華"); // 再次呼叫，傳遞不同參數
    
    return 0;
}

有回傳值的自訂函數
這是最常見的函數類型，就像我們的飲料店例子，它會處理一些事情並回傳一個結果。定義時，必須在函數名稱前宣告回傳值的「型別」(例如 int, double, string)。

#include <iostream>

// --- 定義一個計算圓面積的函數 ---
// double 表示這個函數會回傳一個 double 型別的數值
double calculateCircleArea(double radius) {
    double area = 3.14159 * radius * radius;
    return area; // 使用 return 關鍵字將結果回傳
}

int main() {
    double r = 5.0;
    
    // 呼叫函數，並用一個變數來接收回傳的結果
    double circleArea = calculateCircleArea(r);
    
    std::cout << "半徑為 " << r << " 的圓面積是: " << circleArea << std::endl;
    
    return 0;
}

函數的原型宣告 (Prototype Declaration)
通常，在呼叫一個函數之前，編譯器需要先看過這個函數的定義。如果你的函數定義寫在 main 函數的後面，直接呼叫會導致編譯錯誤。

解決方法：在 main 之前先做一個「原型宣告」，就像電影上映前的「預告片」，先告訴編譯器：「嘿，後面會有一個長這樣的函數，你先有個底！」

#include <iostream>

// --- 函數原型宣告 ---
// 只需要寫出回傳型別、函數名稱和參數型別，像一個標題。
void showMessage(std::string message);

int main() {
    // 因為上面已經有原型宣告，所以即使函數實作在後面，這裡也可以成功呼叫
    showMessage("原型宣告讓程式碼更有彈性！");
    return 0;
}

// --- 函數的完整定義 ---
// 函數的實作可以放在程式碼的任何地方
void showMessage(std::string message) {
    std::cout << message << std::endl;
}

inline 函數
對於一些非常簡短、頻繁被呼叫的函數，每次呼叫的開銷（例如儲存當前位置、跳轉到函數位置）可能會影響效能。inline 關鍵字提供了一個「建議」給編譯器，希望它能將這個函數的程式碼直接嵌入到呼叫的地方，以空間換取時間。

注意：inline 只是一個建議，編譯器有權忽略它。現代編譯器非常聰明，通常能自行判斷是否該進行內聯優化。

#include <iostream>

// 建議編譯器將此函數設為 inline
inline int add(int a, int b) {
    return a + b;
}

int main() {
    int sum = add(5, 3); // 編譯器可能會將這裡直接替換成 int sum = 5 + 3;
    std::cout << "總和是: " << sum << std::endl;
    return 0;
}

3. 函數與陣列
將陣列傳遞給函數是一個非常常見的操作。但要注意，在 C++ 中，將陣列作為參數傳遞時，實際上传遞的是指向陣列第一個元素的「指標」(地址)。

這意味著函數內部對陣列所做的任何修改，都會直接影響到原始的陣列。

這就像你把家裡鑰匙（陣列的地址）借給朋友（函數），朋友進你家把家具（陣列元素）重新排列，你回家後看到的就是被改動過的樣子。

#include <iostream>

// 函數接收一個整數陣列和它的尺寸
void printAndDouble(int arr[], int size) {
    std::cout << "在函數中，原始陣列為: ";
    for (int i = 0; i < size; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;

    // 將陣列中的每個元素都加倍
    for (int i = 0; i < size; ++i) {
        arr[i] = arr[i] * 2;
    }
}

int main() {
    int numbers[] = {1, 2, 3, 4, 5};
    int arraySize = 5;

    std::cout << "在 main 中，呼叫前陣列為: ";
    for (int i = 0; i < arraySize; ++i) {
        std::cout << numbers[i] << " ";
    }
    std::cout << std::endl;

    // 將陣列傳遞給函數
    printAndDouble(numbers, arraySize);

    std::cout << "在 main 中，呼叫後陣列為: ";
    // 觀察原始陣列是否被修改
    for (int i = 0; i < arraySize; ++i) {
        std::cout << numbers[i] << " "; // 輸出: 2 4 6 8 10
    }
    std::cout << std::endl;

    return 0;
}

4. 變數的範圍 (Scope)
變數的「生命週期」和「可見範圍」取決於它被宣告的位置。

區域變數 (Local Variables)
在函數內部（或任何 {} 區塊內）宣告的變數，就是區域變數。它的生命僅限於該函數或區塊內，一旦函數執行完畢，這個變數就會被銷毀。

生活比喻：你在腦海裡想的事情，只有你自己知道，離開這個思緒後就忘了。

全域變數 (Global Variables)
在所有函數外部宣告的變數，就是全域變數。它從程式開始執行時就存在，直到程式結束才被銷毀。任何一個函數都可以存取和修改它。

生活比喻：貼在社區公佈欄上的公告，所有人都能看到，也都能去塗改它。

#include <iostream>

// --- 全域變數 ---
// 任何函數都可以存取它
int globalCounter = 100;

void myFunction() {
    // --- 區域變數 ---
    // 只有 myFunction 能存取它
    int localValue = 10;
    
    globalCounter += 5; // 修改全域變數
    
    std::cout << "在 myFunction 中: " << std::endl;
    std::cout << "  - 區域變數 localValue: " << localValue << std::endl;
    std::cout << "  - 全域變數 globalCounter: " << globalCounter << std::endl;
}

int main() {
    myFunction();
    
    // std::cout << localValue << std::endl; // 這行會產生編譯錯誤，因為 main 無法存取 myFunction 的區域變數
    
    globalCounter = 0; // main 也可以修改全域變數
    
    std::cout << "在 main 中: " << std::endl;
    std::cout << "  - 全域變數 globalCounter: " << globalCounter << std::endl;
    
    return 0;
}

使用建議：盡量避免使用全域變數。因為它們可以被任何地方意外地修改，使得程式難以追蹤和除錯，就像一個沒有管理的公共資源，很容易造成混亂。

5. 多載與範本
函數多載 (Overloading)
C++ 允許我們定義多個同名但參數列表不同的函數。編譯器會根據你呼叫時提供的參數型別、數量或順序，自動選擇正確的版本來執行。

生活比喻：動詞「打開」。你可以「打開門」、「打開瓶蓋」、「打開電腦」。同樣是「打開」這個動作，但根據對象（參數）的不同，實際的作法也完全不同。

#include <iostream>

// 版本1：印出整數
void print(int i) {
    std::cout << "這是一個整數: " << i << std::endl;
}

// 版本2：印出浮點數
void print(double f) {
    std::cout << "這是一個浮點數: " << f << std::endl;
}

// 版本3：印出字串
void print(std::string s) {
    std::cout << "這是一個字串: \"" << s << "\"" << std::endl;
}

int main() {
    print(10);       // 呼叫版本1
    print(3.14);     // 呼叫版本2
    print("Hello");  // 呼叫版本3
    return 0;
}

函數範本 (Template)
如果我們想寫一個函數，它的邏輯完全相同，只是處理的資料型別不同（例如，一個比較兩個數大小的函數，不管是 int, double 還是 char，比較邏輯都一樣），難道要為每種型別都寫一個多載版本嗎？

這時「範本」就派上用場了。函數範本像一個「模具」，可以根據你提供的資料型別，自動生成對應版本的函數。

生活比喻：一個餅乾模具（範本）。你可以用它來壓製麵粉糰（int）、巧克力糰（double）或杏仁糰（string），做出來的餅乾形狀都一樣，只是材料不同。

#include <iostream>

// T 是一個範本參數，代表一個通用的資料型別
template <typename T>
T findMax(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    // 編譯器會根據參數自動生成 int 版本的 findMax
    std::cout << "Max(5, 10) = " << findMax(5, 10) << std::endl;
    
    // 編譯器會自動生成 double 版本的 findMax
    std::cout << "Max(3.14, 2.71) = " << findMax(3.14, 2.71) << std::endl;
    
    // 我們也可以明確指定要生成的版本
    std::cout << "Max('A', 'Z') = " << findMax<char>('A', 'Z') << std::endl;
    
    return 0;
}

6. 遞迴 (Recursion)
遞迴的概念
遞迴是一個強大但有時難以理解的概念：一個函數直接或間接地呼叫了它自己。

要成功設計一個遞迴函數，必須滿足兩個條件：

遞迴關係 (Recursive Step)：將一個大問題，拆解成一個「規模更小」的「相同問題」。

基本情況 (Base Case)：必須有一個明確的「終止條件」，讓遞迴不再繼續下去，否則會陷入無窮迴圈，直到耗盡記憶體（稱為 Stack Overflow）。

生活比喻：

俄羅斯娃娃：你想打開一個俄羅斯娃娃，發現裡面還有一個小一點的俄羅斯娃娃（遞迴關係）。你繼續這個過程，直到你打開到最小的那個、裡面再也沒有娃娃的實心娃娃為止（基本情況）。

問路：你想知道隊伍中排第 10 的人是誰。你跑去問排第 10 的人，他說：「我不知道，但我後面是排第 9 的人」。於是你跑去問排第 9 的人... 直到你問到排第 1 的人，他直接告訴你他的名字（基本情況）。然後你再把答案一層層傳回來。

遞迴的實例：階乘計算
計算 n! (n 的階乘) 是遞迴最經典的例子。
n! = n * (n-1) * (n-2) * ... * 1

遞迴關係：n! = n * (n-1)!。把計算 n! 的問題，簡化成了計算 (n-1)! 這個規模更小的相同問題。

基本情況：0! 的值定義為 1。這是遞迴的終點。

#include <iostream>

long long factorial(int n) {
    // 基本情況 (Base Case): 當 n 為 0 時，遞迴停止，回傳 1
    if (n == 0) {
        return 1;
    } 
    // 遞迴關係 (Recursive Step): 函數呼叫自己，但問題規模減小 (n-1)
    else {
        return n * factorial(n - 1);
    }
}

int main() {
    int num = 5;
    std::cout << num << " 的階乘是: " << factorial(num) << std::endl; // 5 * 4 * 3 * 2 * 1 * 1 = 120
    return 0;
}

遞迴能用非常優雅簡潔的程式碼解決一些複雜問題（例如樹的遍歷、排序演算法），但也要小心它的效能開銷和可能導致的堆疊溢位問題。