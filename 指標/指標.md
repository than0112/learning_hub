9.1 位址的概念與取址運算子 &
位址的概念
在我們開始談論指標之前，必須先理解一個最根本的概念：記憶體位址 (Memory Address)。

生活化解釋：想像一下，電腦的主記憶體（RAM）就像一條非常長的街道，街道上有很多房子，每一棟房子都有一個獨一無二的「門牌號碼」。這個「門牌號碼」就是位址。當我們在程式中宣告一個變數時，例如 int age = 25;，作業系統就會在這條街上找一棟空房子（一塊記憶體空間），把 25 這個數值放進去，然後把這棟房子命名為 age。

取址運算子 &
那麼，我們要怎麼知道變數 age 這棟房子的門牌號碼是多少呢？C++ 提供了一個專門的工具：取址運算子 &。

當 & 放在一個變數名稱前面時，它的作用就是「取得該變數的記憶體位址」。
```C++
#include <iostream>
using namespace std;
int main() {
    int age = 25;

    // 使用 & 取得變數 age 的記憶體位址
    cout << "變數 age 的值是: " << age << endl;
    cout << "變數 age 的記憶體位址是: " << &age << endl;

    return 0;
}

執行這段程式碼，你會看到 &age 印出了一串像 0x7ffee1b5d8ac 這樣的十六進位數字，這就是 age 在記憶體中的「門牌號碼」。

9.2 指標的意義與操作
9.2.1 指標的意義
現在我們知道如何取得位址了，但要如何「儲存」和「使用」這個位址呢？這就是指標 (Pointer) 的用途。

生活化解釋：指標本身也是一個變數，但它很特別，它不住人，也不放貴重物品。它就像一張「便條紙」，上面專門用來記錄別棟房子的門牌號碼。透過這張便條紙，我們就能找到對應的房子。

所以，指標是一個專門用來儲存「記憶體位址」的變數。

9.2.2 指標的宣告
宣告一個指標變數的語法是在型別名稱後面加上一個星號 *。

// 語法: 資料型別 *指標名稱;

int *ptr_age;    // 一個指標，它準備用來存放「整數(int)變數」的位址。
double *ptr_salary; // 一個指標，它準備用來存放「浮點數(double)變數」的位址。
char *ptr_grade;   // 一個指標，它準備用來存放「字元(char)變數」的位址。
```*` 號告訴編譯器：「嘿，這個 `ptr_age` 不是普通的整數變數，它是一張準備記錄整數門牌號碼的便條紙！」

### 9.2.3 取值運算子 `*`

如果我們手上有一張寫著位址的便條紙（指標），要如何知道那棟房子裡到底住了誰（儲存了什麼值）呢？這時就需要另一個運算子，恰好，它也長得像星號 `*`，我們稱之為**取值 (Dereference) 或稱間接存取 (Indirection) 運算子**。

當 `*` 放在一個**已經宣告過的指標變數前面**時，它的意思是：「**不要告訴我這張便條紙上寫的位址，請直接去那個位址，把裡面的東西拿給我！**」

### 9.2.4 指標的初始化

宣告指標後，我們需要將一個變數的位址存入其中。

```cpp
#include <iostream>

int main() {
    int score = 95;      // 一棟叫 score 的房子，裡面住了 95
    int *ptr_score;      // 宣告一張叫 ptr_score 的便條紙

    ptr_score = &score;  // 將 score 的門牌號碼(&)寫到便條紙上

    // 現在，讓我們來使用這張便條紙
    cout << "score 的值: " << score << endl;
    cout << "score 的位址: " << &score << endl;
    cout << "ptr_score 上記錄的位址: " << ptr_score << endl;
    cout << "透過 ptr_score 找到的值: " << *ptr_score << endl; // 使用 * 取值

    // 更厲害的是，可以透過指標修改原變數的值
    *ptr_score = 100; // 去 ptr_score 記錄的位址，把裡面的值改成 100
    cout << "修改後，score 的值變為: " << score << endl; // score 的值真的變了！

    return 0;
}

9.2.5 & 與 * 比較
這兩個運算子是新手最容易混淆的地方，但它們的職責非常分明：

運算子

名稱

使用時機

生活化比喻

範例 (int var=10; int *ptr=&var;)

&

取址 (Address-of)

放在一般變數前

查看房子的門牌號碼

&var (取得 var 的位址)

*

宣告指標 (Declaration)

放在型別後

宣告一張新的便條紙

int *p; (宣告一個叫 p 的指標)

*

取值 (Dereference)

放在指標變數前

按照便條紙上的地址，進屋取物

*ptr (取得 ptr 所指位址上的值)

9.3 指標與陣列
指標和陣列在 C++ 中有著密不可分的關係。

核心觀念：一個陣列的名稱，本身就代表著該陣列第一個元素的記憶體位址。

9.3.1 陣列指標的宣告及初始化
因為陣列名稱就是位址，所以我們可以很自然地將它賦予給一個指標。

#include <iostream>
using namespace std;
int main() {
    int numbers[] = {10, 20, 30, 40, 50};
    int *ptr;

    // 這兩種寫法完全等價
    ptr = numbers;          // 寫法1：直接用陣列名稱賦值
    // ptr = &numbers[0];   // 寫法2：取得第一個元素的位址

    cout << "陣列第一個元素的值: " << *ptr << endl; // 輸出 10
    return 0;
}

9.3.2 指標的算術運算
指標最神奇的地方之一就是可以進行算術運算。對一個指標做加減法，不是單純地加減數字，而是以它所指向的「資料型別大小」為單位進行移動。

生活化解釋：你手上有一張記錄著「幸福路10號」的便條紙。當你對這張便條紙執行 +1 的操作時，你得到的不是「幸福路11號」，而是「隔壁鄰居」的地址。如果這條街上住的都是 int (假設佔 4 個位元組)，那麼 ptr+1 就會跳到下 4 個位元組的位址。

#include <iostream>
using namespace std;
int main() {
    int numbers[] = {10, 20, 30, 40, 50};
    int *ptr = numbers; // ptr 指向 numbers[0]

    // 使用指標算術來遍歷陣列
    cout << "使用指標遍歷陣列: " << endl;
    for (int i = 0; i < 5; ++i) {
        // *(ptr + i) 代表從 ptr 的位置，向前移動 i 個單位，然後取出該處的值
       cout << "第 " << i << " 個元素的值: " << *(ptr + i) << endl;
    }
    
    // ptr++ 的用法
    cout << "\n使用 ptr++ 遍歷:" << endl;
    for (int i = 0; i < 5; ++i) {
        cout << *ptr << " ";
        ptr++; // 讓指標移動到下一個元素的位置
    }
    cout << endl;

    return 0;
}

9.4 函數參數的傳遞
指標在函數參數傳遞中扮演了至關重要的角色，它讓我們能夠打破函數的限制，直接修改外部的資料。

9.4.1 傳值呼叫 (Call by Value)
這是 C++ 的預設方式。當你傳遞一個變數給函數時，函數得到的是這個變數的「影本」。

生活化解釋：你把一份文件影印後交給同事。同事在影本上任意塗改，完全不會影響到你手上的正本。

void increment_copy(int x) {
    x = x + 1; // 修改的是影本 x
}
int main() {
    int num = 10;
    increment_copy(num);
    // num 依然是 10，因為函數修改的是影本
}

9.4.2 傳址呼叫 (Call by Address)
我們不傳遞影本，而是將變數的「位址」（透過指標）傳遞給函數。

生活化解釋：你不影印文件，而是直接告訴同事「文件放在我桌上那個藍色資料夾裡」（傳遞位址）。同事根據這個資訊找到正本，直接在上面修改，你桌上的文件當然就被改動了。

void increment_pointer(int *p) {
    *p = *p + 1; // 找到 p 所指位址上的東西，並把它加 1
}
int main() {
    int num = 10;
    increment_pointer(&num); // 傳遞 num 的位址
    // 現在 num 變成了 11
}

9.4.3 傳參考呼叫 (Call by Reference)
這是 C++ 提供的一種更優雅、更安全的「傳址」方式。它使用「引用 &」來達成。

生活化解釋：你沒有告訴同事文件的位置，而是直接對他說：「我們現在把『我的專案報告』這個綽號，賦予給我桌上這份文件」。當同事對「我的專案報告」進行操作時，實際上就是在操作你的正本文件。它在語法上比指標更簡潔，但達成了同樣的效果。

void increment_reference(int &ref) {
    ref = ref + 1; // ref 是外部變數的一個綽號，直接修改
}
int main() {
    int num = 10;
    increment_reference(num); // 直接傳遞變數，語法更直觀
    // 現在 num 也變成了 11
}

C++ 中推薦用來修改外部資料的首選方式

9.5 使用指標之字串
在 C++ 中，我們通常使用 string。但在 C 語言或一些底層應用中，字串是以「字元陣列」的形式存在的，並以一個特殊的空字元 \0 作為結尾。指標是處理這種 C-Style 字串的利器。

一個 char * 型別的指標可以指向一個 C-Style 字串的第一個字元。

#include <iostream>
using namespace std;

int main() {
    // "Hello" 在記憶體中是 {'H','e','l','l','o','\0'}
    char *str = "Hello, World!"; 
    
    cout << "字串是: " << str << endl;

    // 使用指標遍歷字串，直到遇到結束符號 '\0'
    cout << "逐字印出: ";
    char *ptr = str;
    while (*ptr != '\0') {
        cout << *ptr;
        ptr++; // 指標移動到下一個字元
    }
    cout << endl;

    return 0;
}

這個特性讓指標在處理傳統字串剖析、複製等操作時非常靈活且高效。