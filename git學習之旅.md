Git 學習手冊：從基礎到進階的完整指南
第一部分：版本控制與 Git 的基礎
第 1 節：理解版本控制 - 「為何」需要它
1.1 什麼是版本控制系統 (VCS)？
版本控制系統 (Version Control System, VCS) 是一種軟體工具，用於追蹤和管理一組檔案（通常是原始碼）的變更 。其核心功能是記錄每一次的修改，讓開發者可以在未來的任何時間點，回溯到特定的歷史版本。   

在軟體開發中，VCS 扮演著「單一事實來源 (single source of truth)」的角色，確保所有團隊成員都基於相同的程式碼庫工作 。它不僅僅是檔案的備份，更是一個詳盡的資料庫，記錄了每一次變更的細節，包含修改者、修改時間以及修改目的 。   

1.2 VCS 在現代開發中的關鍵重要性
版本控制系統是現代軟體開發不可或缺的基石，其重要性體現在以下幾個方面：

協同合作 (Collaboration)：VCS 支援並行開發，允許多位團隊成員在同一時間對同一個專案進行工作，而不會互相覆蓋彼此的成果。這對於任何規模的團隊，特別是地理上分散的團隊，都是至關重要的基礎 。   

安全網 (Safety Net)：VCS 如同一張安全網，保護程式碼庫免於災難性的錯誤和人為疏失。當引入一個導致系統崩潰的錯誤時，開發者可以輕易地「讓時光倒流」，將專案還原到先前穩定的版本 。   

歷史與可追溯性 (History and Traceability)：為每個檔案保留一份完整且長期的變更歷史，這份日誌對於分析錯誤的根本原因、理解程式碼的演進過程，以及滿足某些行業的法規或合規性要求至關重要 。   

分支與合併 (Branching and Merging)：分支（建立獨立的開發線）和合併（將這些開發線整合回來）是 VCS 的核心功能。它們促進了實驗性的開發和並行工作，讓新功能的開發可以在不影響主程式碼穩定性的情況下進行 。   

DevOps 的基礎：VCS 是 DevOps 文化的核心支柱。它支援現代軟體交付流程所特有的快速迭代、持續整合 (CI) 和成功的部署，是實現敏捷開發和高效交付的關鍵工具 。   

1.3 版本控制系統的演進
版本控制系統的架構隨著開發需求的演變而進化，主要分為三種類型：本地式、集中式和分散式。

本地版本控制系統 (Local VCS)：這是最早期的模型，它在開發者本機上使用一個簡單的資料庫來追蹤檔案的變更（例如 RCS）。這種系統的設計主要針對單一使用者，其致命缺點是所有歷史紀錄都儲存在本機，存在單點故障的風險 。   

集中式版本控制系統 (CVCS)：為了解決協作問題，集中式系統應運而生。它採用主從式架構（Client-Server），由一台中央伺服器保存專案的完整歷史紀錄，開發者從伺服器「取出 (checkout)」檔案進行工作（例如 Subversion、Perforce）。這種模型的優點是管理相對簡單，團隊成員可以清楚了解彼此的工作進度。然而，其最大的缺點是中央伺服器成為了單點故障：一旦伺服器離線，所有人都無法提交變更或協作；如果伺服器硬碟損壞且沒有備份，整個專案的歷史將會遺失 。   

分散式版本控制系統 (DVCS)：這是現代的主流模型（例如 Git、Mercurial）。在 DVCS 中，每個開發者不僅僅是取出檔案的最新版本，而是擁有整個儲存庫的完整本地副本，包含其完整的歷史紀錄 。這種架構帶來了革命性的好處：每個開發者的本地副本都是一個完整的備份，大大降低了單點故障的風險；開發者可以在離線狀態下工作並在本地提交變更；同時，它也支援更靈活、非線性的工作流程 。   

從集中式到分散式的轉變，不僅僅是技術上的升級，更是一場文化和哲學的變革，它極大地促進了軟體開發的民主化。在 CVCS 模型中，開發者需要獲得中央伺服器的提交權限才能進行有意義的貢獻。但在 DVCS 模型中，任何人都可以「克隆 (clone)」一個公開的儲存庫，在本地自由地進行修改、管理自己的版本歷史，而無需任何初始權限。當他們準備好貢獻時，可以透過「拉取請求 (Pull Request)」等機制，提議 將他們的變更整合回原始專案。這種由工具架構所促成的「分叉-拉取請求 (Fork-and-PR)」模型，正是當今全球開源社群蓬勃發展的基石。

表 1：版本控制系統 (VCS) 比較

類型	核心概念	協作模型	主要優勢	主要弱點	範例系統
本地 VCS	在本機電腦上使用資料庫來追蹤檔案變更。	基本上為單人使用，不支援網路協作。	簡單易用。	容易出錯，有單點故障風險。	RCS
集中式 VCS (CVCS)	所有版本化的檔案都儲存在單一的中央伺服器上。	主從式架構，所有開發者都與中央伺服器同步。	易於管理，團隊成員之間有較高的可見度。	中央伺服器是單點故障；需要網路連線才能提交。	Subversion (SVN), Perforce
分散式 VCS (DVCS)	每個開發者都擁有儲存庫的完整本地副本，包含全部歷史紀錄。	點對點模型，開發者可以在本地提交，並在不同儲存庫之間同步。	支援離線工作；每個副本都是完整備份；速度快；工作流程靈活。	相較於 CVCS，初期的學習曲線可能稍高。	Git, Mercurial

匯出到試算表
第 2 節：Git 簡介 - 「什麼是」與「如何運作」
2.1 Git 的起源：因應需求而生的解決方案
Git 於 2005 年由 Linux 的創始人 Linus Torvalds 為了管理龐大的 Linux 核心專案而創造 。當時，Linux 核心團隊使用的分散式版本控制系統 BitKeeper，因其免費授權被撤銷，迫使 Torvalds 必須尋找或創造一個能滿足其嚴苛需求的替代品 。這個背景故事非常重要，它揭示了 Git 的設計目標並非空泛的理想，而是為了解決當時全球最大、最複雜的軟體專案所面臨的實際挑戰。   

2.2 核心設計哲學
Git 的設計深受 Torvalds 在大型分散式專案上的經驗影響，其核心哲學包括：

分散式開發 (Distributed Development)：每個開發者都擁有一個完整的本地儲存庫，包含完整的開發歷史。這使得大部分操作（如查看歷史、建立分支）都可以在本地瞬間完成，無需網路連線，並且極大地提升了工作效率和彈性 。   

速度與效能 (Speed and Performance)：Git 的設計目標之一就是極致的速度。Torvalds 的標準是「打補丁 (patching) 不應超過三秒」。由於絕大多數操作都是在本地進行，加上其優化的資料結構，Git 的效能遠超許多早期的版本控制系統 。   

資料完整性 (Data Integrity)：Git 透過密碼學雜湊演算法 (SHA-1) 來保護程式碼的完整性。儲存庫中的每一個檔案和每一次提交都會經過校驗和 (checksum) 計算，並以其雜湊值作為唯一的參照。這意味著任何對檔案或歷史紀錄的竄改都會被 Git 立即偵測到，為程式碼提供了強大的保護，防止意外或惡意的損壞 。   

非線性工作流程 (Non-Linear Workflows)：Git 天生就為高效處理分支和合併而設計。在 Git 中，分支是一個極其輕量的「指標」，建立和切換分支的操作成本極低。這使得開發者可以隨時為新功能或實驗性想法建立分支，鼓勵將並行開發作為常態 。   

快照而非差異 (Snapshots, Not Differences)：這是 Git 在架構上的一個關鍵區別。許多舊的 VCS 記錄的是檔案之間的差異（deltas），而 Git 則將其資料視為專案在不同時間點的「快照 (snapshots)」流 。每次提交時，Git 會對整個專案的狀態拍下一張快照。為了提高效率，如果檔案沒有變更，Git 不會重複儲存該檔案，而只是儲存一個指向前一個相同檔案的連結 。   

Git 的核心架構是其強大功能的技術基礎。它將內容表示為一個由快照物件組成的「有向無環圖 (Directed Acyclic Graph, DAG)」。每一次提交都是一個不可變的快照，並透過其密碼學雜湊值連結到其父提交 。這樣的結構確保了整個歷史紀錄的可驗證性（資料完整性）。由於一個分支僅僅是一個指向圖中某個提交的輕量級指標 ，建立和合併分支的操作就變得極為快速。同時，因為大部分操作都只是在本地操作這個圖形結構，所以它們不受網路延遲的影響，從而實現了極高的速度。理解 DAG 模型，能幫助學習者從僅僅知道 Git「能做什麼」，進階到了解它「為何能如此高效地做到」。   

第二部分：開始使用 Git
第 3 節：安裝與初次設定
3.1 在您的系統上安裝 Git
安裝 Git 的過程相當直接，以下是針對三大主流作業系統的建議安裝方法。

Windows：

官方安裝程式 (建議)：前往官方網站 git-scm.com 下載並執行安裝程式。安裝過程中的大部分預設選項都適用於一般使用者 。   

其他方法：也可以使用 Windows 內建的套件管理器 winget (winget install --id Git.Git) ，或第三方套件管理器 Chocolatey (   

choco install git) ，以及適用於 Linux 的 Windows 子系統 (WSL) 來安裝 。   

macOS：

Xcode 命令列工具 (最簡單)：在終端機中首次嘗試執行 git 命令時，系統會提示您安裝 Xcode Command Line Tools，其中已包含 Git 。   

Homebrew (版本較新)：如果您使用 Homebrew 套件管理器，可以執行 brew install git 來安裝最新版本的 Git 。   

官方安裝程式：也可以從 git-scm.com 下載二進位安裝檔進行安裝 。   

Linux：

Debian/Ubuntu (apt)：使用 apt 套件管理器安裝：sudo apt install git-all 。   

Fedora/CentOS/RHEL (dnf/yum)：使用 dnf 或 yum 套件管理器安裝：sudo dnf install git-all 或 sudo yum install git-all 。   

驗證安裝：無論使用何種作業系統，安裝完成後，都可以在終端機中執行以下命令來確認 Git 是否安裝成功及其版本：

Bash

git --version
   

3.2 初次設定：設定您的身分
在安裝 Git 之後，第一件也是最重要的事情，就是設定您的使用者名稱和電子郵件地址。這項資訊會被永久地嵌入到您所建立的每一次提交中，作為該次變更的作者身分標識，無法更改 。   

使用以下命令進行全域設定，這將適用於您電腦上的所有 Git 儲存庫：

Bash

git config --global user.name "Your Name"
git config --global user.email "you@example.com"
   

您可以使用 git config --list 來查看所有設定，或使用 git config user.name 來檢查特定設定值 。   

3.3 理解設定層級
Git 的設定變數儲存在三個不同的層級，它們之間存在著優先級關係：本地設定會覆蓋全域設定，而全域設定會覆蓋系統設定。

系統層級 (--system)：此設定適用於電腦上的所有使用者和他們的所有儲存庫。設定檔通常位於 [path]/etc/gitconfig 。   

全域層級 (--global)：此設定適用於目前使用者及其所有儲存庫。這是最常用的設定層級，設定檔位於 ~/.gitconfig 或 ~/.config/git/config 。   

本地層級 (--local)：此設定僅適用於您目前所在的特定儲存庫，這是預設的作用域。設定檔位於該儲存庫的 .git/config 檔案中 。   

這種分層的設定系統提供了強大的靈活性，它允許開發者在保持跨專案一致性（如身分和偏好的編輯器）的同時，也能針對特定專案進行客製化。例如，一位開發者可以將個人 email 設定為全域配置，然後在公司的專案儲存庫中，設定一個本地的 email 來覆蓋全域設定，以區分工作和個人貢獻。這種設計優雅地解決了在不同專案中管理多重身分和設定的問題。

第 4 節：您的第一個儲存庫
4.1 使用 git init 建立儲存庫
git init 是將一個普通目錄轉換為 Git 儲存庫的命令 。執行此命令後，Git 會在該目錄下建立一個名為    

.git 的隱藏子目錄。這個 .git 目錄是儲存庫的「大腦」，包含了所有必要的元數據、物件資料庫和設定檔 。   

初始化一個新專案：在一個空目錄中執行 git init。

將現有專案納入版控：進入現有專案的根目錄，執行 git init 。   

4.2 三個區域：Git 的核心架構
要順利地學習 Git，必須先建立一個關於其核心架構的心智模型。一個 Git 專案主要由三個區域組成 ：   

工作目錄 (Working Directory)：這是您在電腦硬碟上能看到並直接編輯的專案檔案。它是從 Git 儲存庫中取出的某個版本的單一檢出 (checkout) 。   

暫存區 (Staging Area)：也稱為「索引 (Index)」，這是一個位於 .git 目錄中的檔案，它像一個草稿區，儲存了您準備要放入下一次提交的變更內容。您可以在此精心挑選和組合變更，以建立一個有意義的提交 。   

Git 目錄 (Repository)：這就是 .git 資料夾，是 Git 儲存專案元數據和物件資料庫（即所有提交和快照）的地方。這是 Git 最重要的部分 。   

檔案在這些區域之間的流動，形成了其狀態的生命週期：

已修改 (modified)：您在工作目錄中修改了檔案，但尚未提交。

已暫存 (staged)：您將已修改的檔案標記，準備將其目前版本納入下一次提交快照中。

已提交 (committed)：資料已安全地儲存在您的本地儲存庫中。

   

4.3 基本工作流程：status, add, commit
這是 Git 中最基本也最頻繁使用的核心工作流程 。   

git status - 檢查狀態
這是您用來檢視儲存庫狀態的主要命令。它會告訴您哪些檔案被修改了、哪些檔案已被暫存，以及是否有任何未被追蹤的檔案 。養成隨時執行此命令的習慣，可以幫助您清楚掌握目前的工作進度。   

git add <file> - 加入暫存區
此命令將工作目錄中的變更移至暫存區。一個常見的誤解是認為 git add 是「將檔案加入專案」，更精確的說法是「將檔案目前的狀態加入下一次的提交中」。   

git add <filename>：暫存特定檔案的變更。

git add.：暫存目前目錄下所有已修改和新建立的檔案的變更 。   

git commit - 提交變更
此命令會將目前暫存區中的內容製作成一個快照，並將其永久地儲存到儲存庫的歷史紀錄中 。   

git commit -m "Your descriptive message"：使用 -m 旗標直接在命令列中提供一個簡潔的提交訊息 。   

git commit：若不加 -m，Git 會開啟您設定的文字編輯器，讓您可以撰寫更詳細的多行提交訊息 。   

暫存區是 Git 設計中的一個精妙之處，它不僅僅是一個中介步驟，而是製作「原子提交 (atomic commit)」的工藝平台。在沒有暫存區的系統中，如果一位開發者在同一個檔案中進行了兩項不相關的修改（例如，修復一個錯誤並同時進行一些程式碼重構），他將被迫將這兩項修改放在同一個提交中，這會產生一個「混合關注點」的提交，污染了專案歷史。這樣的歷史紀錄不僅難以閱讀，也使得使用 git bisect 等工具追蹤錯誤或還原特定變更變得更加困難。暫存區提供了必要的控制權，讓開發者能夠精確地選擇哪些變更應該被包含在一次提交中，從而建立出「原子提交」——即每一次提交都只代表一個單一、完整的邏輯工作單元。這種實踐是專業軟體開發的基石，而暫存區正是實現這一點的關鍵機制 。   

4.4 使用 git log 查看專案歷史
git log 命令用於探索專案的提交歷史紀錄 。單獨使用時，它會顯示詳細的提交資訊，但通常會搭配一些選項來使輸出更易於閱讀：   

--oneline：將每一次提交壓縮成一行，只顯示簡短的雜湊值和提交訊息，非常適合快速概覽 。   

--graph：在輸出左側繪製一個 ASCII 圖形，視覺化地展示分支和合併的歷史 。   

--decorate：顯示指向每個提交的分支和標籤名稱 。   

--all：顯示所有分支的歷史，而不僅僅是目前分支。

這些選項經常被組合使用，以獲得一個強大且清晰的歷史概覽：

Bash

git log --oneline --graph --decorate --all
   

-p：顯示每一次提交所引入的完整「補丁 (patch)」或差異 (diff)，詳細列出每一行的變更內容 。   

第三部分：精通分支
第 5 節：分支的力量
5.1 什麼是分支？
在 Git 中，一個分支並不是程式碼庫的一份完整拷貝。它是一個極其輕量的、可移動的指標，指向某一個特定的提交 。這個基礎概念是 Git 分支操作之所以快速且低成本的關鍵，與許多舊式版本控制系統形成鮮明對比，在那些系統中建立分支通常是一個耗時且佔用大量儲存空間的操作 。   

5.2 分支的主要優勢
並行開發 (Parallel Development)：分支允許多位開發者同時在不同的功能上工作，而不會互相干擾。每位開發者都在一個隔離的環境中進行修改，直到準備好整合為止 。   

功能隔離 (Feature Isolation)：所有與新功能相關的工作都可以被封裝在其專屬的分支中。這能保持主分支（通常是 main 或 master）的乾淨與穩定，確保它隨時處於可部署的狀態 。   

風險管理與實驗 (Risk Mitigation and Experimentation)：分支提供了一個安全的沙盒環境，可以用來實驗新想法、進行大規模的程式碼重構或修復錯誤，而不用擔心會破壞主程式碼庫。如果一個想法最終行不通，可以輕易地拋棄該分支，對主專案沒有任何影響 。   

第 6 節：分支管理
6.1 列出分支
git branch：列出您所有的本地分支。目前所在的分支會以星號 * 標示 。   

git branch -r：列出所有遠端追蹤分支 。   

git branch -a：列出所有本地和遠端追蹤分支 。   

6.2 建立分支
git branch <branch-name>：從您目前的提交點建立一個名為 <branch-name> 的新分支。需要特別注意的是，這個命令只會建立分支，並不會自動切換到該分支上 。   

6.3 切換分支：checkout vs. switch
傳統方法：git checkout

git checkout <branch-name>：切換到一個已存在的分支 。   

git checkout -b <new-branch-name>：這是一個常用的快捷方式，它會同時建立一個新分支並立即切換過去 。   

現代方法：git switch

git switch 是在 Git 2.23 版本中引入的新命令，它更安全、更直觀，專門用於切換分支 。   

git switch <branch-name>：切換到一個已存在的分支 。   

git switch -c <new-branch-name>：建立一個新分支並切換過去 。   

git switch 的出現是為了改善使用者體驗，因為舊的 git checkout 命令功能「過載」，同時處理分支切換、檔案還原和分離 HEAD 等多種操作，這對初學者來說容易造成混淆 。   

git switch 和 git restore 的引入，反映了 Git 在使用者介面設計上的成熟演進。它從一個功能過載的命令 (checkout) 轉向更明確、單一職責的命令。這種關注點分離是優秀軟體設計的經典原則。舊的 git checkout <commit> -- <file> 來還原檔案的語法並不直觀，而新的 git restore <file> 則非常明確。同樣地，git switch 清楚地表明您只在切換分支，而不會有意外覆蓋工作目錄中檔案的風險。這個演進顯示了 Git 的維護者在不犧牲其強大功能的前提下，正積極地使其工具對使用者更加友好。

6.4 刪除分支
安全刪除 (-d)：git branch -d <branch-name> 會刪除一個本地分支，但前提是該分支的變更已經被完全合併到您目前所在的分支中。這是一個安全機制，用以防止意外遺失工作成果 。   

強制刪除 (-D)：git branch -D <branch-name> 是 --delete --force 的縮寫。它會強制刪除分支，無論其合併狀態如何。當您確定要完全捨棄某個分支上的工作時，就需要使用此命令 。   

刪除遠端分支：git push origin --delete <branch-name>：刪除遠端儲存庫上的分支 。   

第 7 節：整合變更
7.1 git merge 命令
git merge <branch-name> 是將指定分支的變更整合到目前所在分支的主要命令 。   

7.2 合併策略：快進式 vs. 三方合併
理解這兩種合併策略對於掌握 Git 的歷史紀錄至關重要。

快進式合併 (Fast-Forward Merge)

發生時機：當從目前分支的頂端到目標分支的頂端存在一條直接、線性的路徑時發生。這意味著自從目標分支建立以來，目前分支上沒有任何新的提交 。   

運作方式：Git 不會建立一個新的「合併提交」，而是簡單地將目前分支的指標向前移動，使其指向與目標分支相同的提交點 。   

產生的歷史：歷史紀錄保持完美的線性，非常乾淨 。   

三方合併 (Three-Way Merge)

發生時機：當兩個分支已經「分叉 (diverged)」時發生。也就是說，自從它們的共同祖先以來，目前分支和目標分支上都有了新的提交 。   

運作方式：Git 會找到這兩個分支的共同祖先，然後建立一個全新的合併提交 (merge commit)。這個特殊的提交有兩個父提交，它將兩個分支的變更內容結合在一起 。   

產生的歷史：歷史紀錄變為非線性，合併提交明確地標示出兩條獨立的開發線在哪裡被重新匯合 。   

強制建立合併提交：即使可以進行快進式合併，您也可以使用 --no-ff 旗標來強制 Git 建立一個合併提交。這種做法常用於明確記錄某個功能分支的整合點，保留其開發脈絡 。   

選擇保留歷史（三方合併）還是創造線性歷史（快進式合併，通常透過 rebase 實現）的合併策略，反映了一個團隊對其工作流程哲學的根本決策。這是在「歷史的精確性」與「歷史的可讀性」之間所做的權衡。三方合併產生的合併提交，如實記錄了「在某個時間點，來自 X 分支的工作被整合進來」，這是一個歷史上完全準確但可能較為雜亂的紀錄。而 rebase 後的快進式合併則重寫了歷史，使其看起來像是「X 分支的工作一直都是在最新的 main 分支之後依序開發的」，這是一個理想化、線性的歷史，通常更易於閱讀，但卻抹去了並行開發的實際發生情境。這不僅僅是命令的選擇，而是一個團隊決定如何講述他們專案故事的方式。

7.3 解決合併衝突
當兩個分支對同一個檔案的相同幾行程式碼進行了不同的修改時，Git 無法自動判斷應該保留哪個版本，這時就會發生「合併衝突 (merge conflict)」。   

以下是從命令列解決衝突的步驟教學 ：   

識別衝突：Git 會暫停合併過程，並提示哪些檔案存在衝突。執行 git status 會顯示「未合併的路徑 (Unmerged paths)」。   

編輯衝突檔案：打開有衝突的檔案，您會看到類似以下的衝突標記：

<<<<<<< HEAD
這是您目前分支的變更內容。
=======
這是您要合併進來的分支的變更內容。
>>>>>>> <branch-name>
   


您需要手動編輯檔案，決定最終要保留的內容——可以是其中一個版本，也可以是兩者的結合，或是全新的內容。完成後，務必刪除所有衝突標記 (<<<<<<<, =======, >>>>>>>)。

標記為已解決：編輯完成後，使用 git add <resolved-file> 命令來告訴 Git 衝突已經解決 。   

完成合併：執行 git commit 來完成合併並建立合併提交。Git 通常會自動產生一個預設的提交訊息，說明這是一次合併 。   

實用命令：git log --merge 可以幫助查看導致衝突的提交；git merge --abort 可以在遇到問題時取消本次合併，回到合併前的狀態 。   

第四部分：與遠端儲存庫協作
第 8 節：使用遠端儲存庫
8.1 什麼是遠端儲存庫？
「遠端儲存庫 (remote repository)」是托管在網際網路或內部網路上的專案版本，通常位於像 GitHub、GitLab 或 Bitbucket 這樣的平台上 。它的主要目的是提供一個集中的地方，讓團隊成員可以共享和同步他們的工作，是實現團隊協作的基礎 。一個「遠端 URL」就是這個儲存庫的網路位址 。   

8.2 克隆現有儲存庫
git clone <url> 是您與一個遠端專案開始互動的第一步 。   

這個命令會建立一個遠端儲存庫的完整本地副本，包含所有的檔案、提交歷史和分支。

它會自動設定一個名為 origin 的遠端參照，指向您克隆的 URL，方便您後續與之互動 。   

8.3 將遠端新增至本地儲存庫
如果您在本地使用 git init 建立了一個儲存庫，並希望將它與一個新的、通常是空的遠端儲存庫連結，可以使用 git remote add origin <url> 命令 。   

origin 是一個約定俗成的名稱，代表主要的遠端儲存庫。

您可以使用 git remote -v 來查看目前設定的所有遠端儲存庫及其 URL 。   

第 9 節：同步您的工作
9.1 將變更推送到遠端 (git push)
git push <remote-name> <branch-name> 用於將您本地的提交上傳到指定的遠端分支 。   

最常見的命令是 git push origin main，它會將您本地 main 分支的提交推送到 origin 遠端的 main 分支 。   

當您第一次推送一個新建立的本地分支時，使用 -u 或 --set-upstream 旗標（例如 git push -u origin feature/new-feature）會將您的本地分支與遠端分支連結起來。這樣設定之後，未來您在該分支上只需執行 git push 即可，Git 會自動知道要推送到哪裡 。   

9.2 fetch 與 pull 的區別
這是 Git 新手最容易混淆的概念之一，理解它們的區別對於避免衝突至關重要。

git fetch - 僅下載，不整合
git fetch 會從遠端儲存庫下載所有新的資料（新的提交、分支、標籤），但它不會自動將這些變更整合到您目前的本地工作目錄中。它只會更新您的「遠端追蹤分支」（例如 origin/main）。這是一個「安全」的操作，您可以隨時執行它來查看遠端有什麼新進度，而不會影響您正在進行的工作。   

git pull - 下載並整合
git pull 是一個複合命令，它實際上是兩個命令的組合：它會先執行一次 git fetch，然後立即執行一次 git merge（或 git rebase）來將下載的變更整合到您目前的本地分支中 。這是一個潛在的「不安全」操作，因為如果您的本地有未提交的變更，或者遠端變更與您的本地提交有衝突，它可能會立即引發合併衝突。   

工作流程建議
一個更安全、更具控制性的工作流程是：先使用 git fetch 來獲取遠端的更新，然後使用 git log main..origin/main 或 git diff main origin/main 來檢查有哪些新的變更，最後再手動執行 git merge origin/main 來整合這些變更。這個流程將「獲取遠端資訊」和「整合遠端變更」這兩個步驟分開，讓您在整合之前有機會審視和決策，這在複雜的協作環境中至關重要 。   

第 10 節：協作工作流程：拉取/合併請求
10.1 什麼是拉取請求和合併請求？
「拉取請求 (Pull Request, PR)」(在 GitHub 中使用)  和「合併請求 (Merge Request, MR)」(在 GitLab 中使用)  是現代軟體開發中協作的核心機制。它是一種向儲存庫提出變更的正式請求，請求維護者將您的功能分支「拉取」或「合併」到主幹分支（如    

develop 或 main）中。

PR/MR 是程式碼審查 (code review) 和團隊協作的基石 。它們提供了一個專門的平台，讓團隊成員可以在變更被整合前，逐行審查程式碼、討論實作細節，並執行自動化檢查。   

10.2 PR/MR 的生命週期
一個典型的 PR/MR 工作流程如下 ：   

建立：開發者將其功能分支推送到遠端，然後在 GitHub/GitLab 介面上建立一個 PR/MR，並提供清晰的標題和描述來說明變更的內容和目的。

程式碼審查：團隊成員被指派為審查者。他們會檢查程式碼，在特定程式碼行上留下評論、提出問題或建議改進。

討論與迭代：作者根據回饋進行回應，並在功能分支上進行額外的提交來解決問題，然後將更新推送到遠端。PR/MR 會自動顯示最新的提交。

批准：當審查者對變更感到滿意時，他們會批准該 PR/MR。

合併：儲存庫的維護者將 PR/MR 合併，將功能分支的提交整合到目標分支中。合併後，功能分支通常會被刪除。

10.3 功能分支工作流程實踐
這是業界最流行和推薦的工作流程之一，它結合了分支和 PR/MR 的優勢 。   

與主分支同步：開始新工作前，確保您的本地主分支是最新版本。

Bash

git checkout main
git pull origin main
建立功能分支：為您的任務建立一個描述性的新分支。

Bash

git switch -c feature/user-authentication
開發與提交：在功能分支上進行程式碼修改。建立小而專一的「原子提交」，並撰寫清晰的提交訊息。

Bash

#... 進行程式碼修改...
git add.
git commit -m "feat: Add password validation"
推送分支：將您的功能分支推送到遠端儲存庫，以便備份和與他人共享。

Bash

git push -u origin feature/user-authentication
建立拉取請求：前往 GitHub/GitLab 網站，從您的功能分支向 main 或 develop 分支發起一個 PR/MR。

協作與審查：參與程式碼審查過程，根據回饋進行修改和討論。

合併：一旦 PR/MR 被批准，由維護者將其合併。

第五部分：進階技巧與最佳實踐
第 11 節：復原變更與重寫歷史
11.1 reset、revert 與 checkout 的比較
這三個命令都可用於復原變更，但它們的作用範圍和對歷史紀錄的影響截然不同，理解它們的區別至關重要。

git revert <commit>

操作：建立一個新的提交，其內容與您指定的提交完全相反。它透過新增歷史來「復原」變更，而不是刪除歷史 。   

範疇：提交層級。

安全性：對已發布的公共/共享分支是安全的，因為它不改變現有的歷史紀錄 。   

git reset <commit>

操作：將目前分支的指標移回至指定的提交，有效地從分支歷史中移除其後的提交 。   

範疇：提交層級。

安全性：對已發布的公共/共享分支是危險的，因為它重寫了歷史。僅適用於復原尚未分享的本地變更 。   

模式：reset 有三種模式，對應 Git 的三個區域：

--soft：只移動分支指標。被重設的提交變更會保留在暫存區。

--mixed (預設)：移動指標並清空暫存區。變更會保留在工作目錄中。

--hard：移動指標、清空暫存區並捨棄工作目錄中的所有相關變更。此操作會導致資料遺失，需謹慎使用 。   

git checkout <commit>

操作：主要用於切換分支，但也可以用來查看舊的提交（進入「分離 HEAD」狀態），或將工作目錄中的檔案還原到之前的狀態（git checkout <commit> -- <file>）。   

範疇：可以是提交層級或檔案層級。

安全性：通常是安全的，但可能會覆蓋工作目錄中未提交的本地變更。

表 2：reset vs. revert vs. checkout 復原變更比較

命令	主要用途	範疇	對公共歷史的影響	產生的狀態
git reset	在私有分支上捨棄提交或復原未提交的變更。	提交層級、檔案層級	危險 (重寫歷史)	分支指標移動，工作區/暫存區根據模式而定。
git revert	在公共分支上安全地復原已提交的變更。	提交層級	安全 (新增歷史)	建立一個新的「反向」提交，原始歷史不變。
git checkout	切換分支或還原工作目錄中的檔案。	提交層級、檔案層級	安全 (不改變歷史)	HEAD 指標移動到不同分支或提交，或工作目錄檔案被覆寫。

匯出到試算表
11.2 使用 git stash 暫存變更
git stash 的目的是暫時儲存您尚未準備好提交的變更（包含已暫存和未暫存的），以便您可以切換到一個乾淨的工作目錄去處理其他緊急事務 。   

基本工作流程如下 ：   

git stash：將目前的變更儲存到一個「儲藏堆疊」中，並清理工作目錄。

git stash list：查看所有已儲藏的變更集。

git stash apply：重新應用最近一次的儲藏，但保留它在儲藏堆疊中。這對於將同一組變更應用到多個分支上很有用 。   

git stash pop：重新應用最近一次的儲藏，並將其從儲藏堆疊中移除。這是最常見的用法 。   

11.3 使用 git rebase 重寫歷史
rebase vs. merge

rebase 和 merge 的目的相同——整合變更——但 rebase 透過重寫提交歷史來達成此目的 。   

rebase 的過程是：它會將您功能分支上的提交逐一地在目標分支（例如 main）的頂端重新應用一次。這會產生一個乾淨、線性的歷史紀錄，看起來就像您的功能是依序開發的，而不是並行開發的 。   

相比之下，merge 會保留並行的歷史，並透過一個合併提交來將它們匯合 。   

Rebase 的黃金法則

請務必遵守這條規則：絕不要對已經被推送到公共/共享分支的提交進行 rebase 。   

原因：rebase 會建立全新的提交並拋棄舊的提交。如果團隊中其他成員已經基於那些舊的提交進行了開發，他們的歷史將會與您 rebase 後的歷史產生分歧。當他們試圖同步時，會導致嚴重的混亂、重複的提交和一個極其混亂的儲存庫 。   

rebase 應該只用於清理您尚未分享的本地、私有歷史。

互動式 Rebase (-i)

git rebase -i <base-commit> 是一個強大的工具，用於在建立拉取請求之前，清理本地的提交歷史 。   

在互動式編輯器中，您可以對每個提交執行不同的命令：

pick：使用該提交。

reword：修改提交訊息。

squash：將該提交的變更合併到前一個提交中，並讓您合併提交訊息 。   

fixup：與 squash 類似，但會完全捨棄該提交的訊息。這對於合併一些小的修正提交非常有用 。   

表 3：git merge vs. git rebase

特性	git merge	git rebase
產生的歷史	非線性，包含合併提交，如實反映並行開發。	線性，沒有合併提交，歷史看起來像依序開發。
歷史完整性	保留原始歷史，是非破壞性操作。	重寫歷史，會建立新的提交並拋棄舊的。
協作安全性	對於公共/共享分支是安全的。	僅對私有、未分享的分支是安全的。
衝突解決	在單一的合併提交中一次性解決所有衝突。	可能需要在重新應用每個提交時，多次解決相同的衝突。

匯出到試算表
第 12 節：必備工具與設定
12.1 使用 .gitignore 忽略檔案
.gitignore 檔案的用途是告訴 Git 哪些檔案或目錄應該被忽略，不要納入版本控制。這通常包括編譯產生的檔案、日誌檔、套件依賴或特定於整合開發環境 (IDE) 的設定檔 。   

語法與模式 ：   

#：用作註解。

*：萬用字元，匹配零或多個字元。

?：匹配任何單一字元。

``：匹配方括號中的任何一個字元。

/：在模式結尾表示這是一個目錄。

**：匹配多層目錄。

!：在模式開頭表示否定，即不要忽略此檔案。

最佳實踐 ：   

專案開始時建立：在專案初期就建立 .gitignore 檔案，以避免不必要的檔案被意外提交。

使用範本：利用社群提供的範本，例如 GitHub 的官方範本庫或 gitignore.io 網站，可以為您的程式語言或框架提供一個良好的起點 。   

使用全域 .gitignore：對於特定於您個人開發環境的檔案（如編輯器設定），可以設定一個全域的 .gitignore 檔案（例如 ~/.config/git/ignore），這樣就不需要在每個專案中重複設定 。   

處理已追蹤的檔案：如果一個檔案已經被 Git 追蹤，之後再將其加入 .gitignore 是無效的。您需要先使用 git rm --cached <file> 將其從索引中移除，然後再提交 .gitignore 的變更 。   

12.2 使用 git diff 比較變更
git diff 是一個多功能的命令，用於顯示不同狀態之間的差異，例如提交之間、分支之間或檔案之間 。   

主要用途：

git diff：顯示未暫存的變更（工作目錄 vs. 暫存區）。

git diff --staged (或 --cached)：顯示已暫存的變更（暫存區 vs. 上一次提交）。

git diff <branch1>..<branch2>：顯示兩個分支頂端之間的差異。

git diff <commit1> <commit2>：顯示兩個特定提交之間的差異。

git diff <branch> -- <file>：比較特定檔案在不同分支中的版本 。   

git diff vs. git status：git status 顯示檔案的狀態（已修改、已暫存等），而 git diff 顯示變更的具體內容 。   

附錄：Git 命令快速參考
表 4：Git 命令快速參考

分類	命令	描述	常用範例
設定與配置	git config	設定使用者身分、別名等配置。	git config --global user.name "Your Name"
git init	在目前目錄初始化一個新的 Git 儲存庫。	git init
基本工作流程	git status	顯示工作目錄和暫存區的狀態。	git status
git add	將檔案變更加入暫存區。	git add. 或 git add <file>
git commit	將暫存區的內容記錄為一個新的提交。	git commit -m "Initial commit"
分支管理	git branch	列出、建立或刪除分支。	git branch -a
git switch	切換分支。	git switch -c new-feature
git merge	將一個分支的變更合併到目前分支。	git merge feature-branch
遠端與協作	git clone	克隆一個遠端儲存庫到本地。	git clone <repository-url>
git remote	管理一組追蹤的遠端儲存庫。	git remote add origin <url>
git fetch	從遠端儲存庫下載物件和參照。	git fetch origin
git pull	從遠端儲存庫獲取並整合變更。	git pull origin main
git push	將本地分支的提交更新到遠端儲存庫。	git push -u origin main
檢視歷史	git log	顯示提交歷史紀錄。	git log --oneline --graph --decorate
git diff	顯示提交、分支或檔案之間的差異。	git diff main..feature
復原變更	git reset	重設目前 HEAD 到指定狀態（可能重寫歷史）。	git reset --hard HEAD~1
git revert	建立一個新的提交來復原先前的提交。	git revert <commit-hash>
git stash	暫時儲藏未提交的變更。	git stash pop
git clean	從工作目錄中移除未被追蹤的檔案。	git clean -fd