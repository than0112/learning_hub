/*本題主要是練習指標的運用以下是題目的描述
函數描述
在下方編輯器中完成更新函數。
更新具有以下參數：
int *a：一個整數
int *b：一個整數

return
該函數被聲明為無返回類型，因此沒有值可以返回。
修改記憶體中的值，使其包含它們的總和並包含它們的絕對差。

輸入格式
輸入將包含兩個整數，和，分開一行。
*/

#include <stdio.h>
#include <cmath>

void update(int *a,int *b) {
   int original_a=*a;
   *a= *a + *b;
   *b = abs(original_a - *b);
       
}

int main() {
    int a, b;
    int *pa = &a, *pb = &b;
    
    scanf("%d %d", &a, &b);
    update(pa, pb);
    printf("%d\n%d", a, b);

    return 0;
}

/*解題思路
 程式碼解說
這個問題的核心在於 update 函式的邏輯，特別是要注意操作的順序。

int original_a = *a;

我們宣告一個暫存變數 original_a 來儲存指標 a 所指向的原始值（也就是 main 函式裡的 a）。

這是最重要的一步。因為如果我們直接執行 *a = *a + *b;，那麼 main 函式裡 a 的原始值就會遺失，導致接下來計算差值時出錯。

*a = *a + *b;

這行程式碼會先計算 *a (原始 a 的值) 和 *b (原始 b 的值) 的和。

然後將這個「和」存回指標 a 所指向的記憶體位置，也就是直接修改了 main 函式中變數 a 的值。

*b = abs(original_a - *b);

這裡我們使用暫存的 original_a 和尚未被修改的 *b 來計算差值。

abs() 函式（來自 <cmath> 標頭檔）會取計算結果的絕對值。

最後，將這個「絕對差」存回指標 b 所指向的記憶體位置，修改了 main 函式中變數 b 的值。
*/











//指標的介紹

/*在C++中，指標用於在不同的上下文（主要是函數）之間共享內存地址。每當一個函數需要修改變數的內容，但沒有所有權時，就會使用它們。

為了訪問變數的內存地址，請在其前面加上符號。例如，&val返回變數的內存地址。

這個內存地址被分配給指標，可以在函數之間共享。例如，將內存地址分配給指標。要訪問指向的內存內容，請在變數名稱前加上*。例如，*p將返回存儲在中的值，對它的任何修改都會在中進行。*/


/*
void increment(int *v) {
(*v)++;

}
int main() {

int a;

scanf("%d", &a);

increment(&a);

printf("%d", a);

return 0;

} 這個函數的主要功能
顯示思路
這個程式碼的主要功能是展示 C/C++ 中的**「傳遞指標」(pass-by-pointer)** 觀念，也就是一個函式如何去修改另一個函式中變數的原始值。

## 核心功能分解
increment 函式:

這個函式的目標是將傳入的整數變數的值增加 1。

它不是接收一個值的「複本」(copy)，而是接收一個指向整數的指標 int *v，也就是變數的記憶體位址。

(*v)++ 這行程式碼的意思是：

*v：透過 * (dereference operator) 找到 v 這個位址上儲存的原始數值。

++：將這個原始數值加一。

main 函式:

宣告一個整數 a。

透過 scanf 讀取一個數字並存入 a。

呼叫 increment(&a)。這裡的 &a 是「取址」運算子，意思是將變數 a 的記憶體位址傳遞給 increment 函式。

increment 函式接收到這個地址後，就直接對 a 的原始值進行了加一操作。

最後 printf 印出被修改過後的 a 的新值。

## 簡單比喻
傳值 (Pass-by-value)：我給你一張我家照片的「影本」。你對影本塗鴉，不會影響我家的原始照片。

傳指標 (Pass-by-pointer) (本次函數的例子)：我給你「我家的地址」。你根據這個地址直接跑到我家，在我家的牆上畫畫。這樣一來，我家的牆就真的被改變了。

總結來說，整個程式的功能就是：從使用者那裡讀取一個數字，透過傳遞指標的方式讓函式將該數字加一，然後印出增加後的結果。
*/